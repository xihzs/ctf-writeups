# jagacha
---

> Description: JAGATSA
> Difficulty: Medium
> Files: [config.py](./config.py) [jagacha.py](./jagacha.py)

---

## Playing Around

```bash
$ nc 159.65.133.6 31708
Welcome to the Jaga Gacha!
We have an event going on featuring the limited SSS-rarity flag-chan!
Here are the Gacha pull rates:
- Jaga-chan: 25 %
- Jaga Hacker: 25 %
- Jaga Scholar: 25 %
- Super Jaga: 25 %
- flag-chan: 0 %
All the best!

Options:
1. Roll a Gacha
2. I'm Feeling Lucky!
3. Exit
> 1

Congrats! You have pulled a Jaga Hacker!
*truncated banner*

Here are the stats of your character:
STR: 45938
DEX: 23978
INT: 59323
LUK: 42117

> 2
Enter your lucky number: 123
Oops! Looks like you are not as lucky as you thought! Try again!
```

As you can see, the program contains 2 options.

The first option simply outputs the gacha result, whilst the second option takes in a number and checks it.

## Reverse Engineering

If we read the source code, we can quickly identify the part of the code that contains the main functionality

```python
from config import (
    FLAG,
    ASCII_JAGA,
    ASCII_JAGAHACKER,
    ASCII_JAGASCHOLAR,
    ASCII_JAGASUPER,
)

def get_seed():
    SEED = 0xdeadc0de
    return SEED + time.time_ns()

rand = random.Random(get_seed())

if option == 1:
    num = rand.getrandbits(64)
    gacha = GACHA_KEYS[num % len(GACHA_KEYS)]
    writer.writelines(
        (
            f"Congrats! You have pulled a {gacha}!\n".encode(),
            GACHAS[gacha],
            b"Here are the stats of your character:\n",
            f"STR: {num>>48 & 0xffff}\n".encode(),
            f"DEX: {num>>32 & 0xffff}\n".encode(),
            f"INT: {num>>16 & 0xffff}\n".encode(),
            f"LUK: {num & 0xffff}\n".encode(),
            b'\n',
        )
    )
elif option == 2:
    num = rand.getrandbits(64)
    lucky_number = await read_number(
        reader, writer, b"Enter your lucky number: "
    )
    if lucky_number == num:
        writer.writelines((
            b"Congrats! You have pulled the limited SSS-rated rarity flag-chan!\n",
            FLAG,
        ))
        option = 3  # Quit
    else:
        writer.write(
            b"Oops! Looks like you are not as lucky as you thought! Try again!\n\n"
        )
elif option == 3:
    writer.write(b"See you again!\n")
```

As you can see, the option 1 simply outputs a random number generated from `rand.getrandbits(64)` while option 2 checks our input against another random number generated similarly.

It is clear that the objective is to be able to guess the output of `rand.getrandbits(64)`.

## Understanding Rand

Before we go any further, we have to understand what is random.

Contrary to expectations, the `random` that we know of is not truly random. In fact, [there is no true randomness in a computer](https://www.sciencefocus.com/future-technology/can-a-computer-generate-a-truly-random-number/).

The randoms that we generate in computers are also known as `Psuedo Random Numbers`.

Computers generate these pseudo random numbers using a **seed**. Let's look at an example:

```python
import random

random.seed(1)
x = random.getrandbits(64)
random.seed(1)
y = random.getrandbits(64)

x == y
```

_The behaviour of using seed to output a pseudo random number can differ between programming languages_

However, this method of guessing a pseudo random number requires knowledge of the seed, which can be difficult to determine, especially in this challenge.

But for the python implementation of random, we can actually guess the randomly generated numbers **IF** we are able to generate a sufficiently large sample of random numbers.

Thankfully, there is a python [library](https://github.com/tna0y/Python-random-module-cracker) that does this, and you can read more on how it works there.

## Cracking the Rand

Going back to the program, we can see that gacha uses **PRNG** _(Pseudo Random Number Generator)_ to generate random numbers, and we can do this as many times as we like.

However, the randcrack library only allows you to submit 32 bit random values, but the value generated by the program are 64 bit values.

With some research, we can determine the following:

```python
import random

# init rand seed 1
random.seed(1)
bit64 = random.getrandbits(64)

# reset rand with seed 1
random.seed(1)
bit32_1 = random.getrandbits(32)
bit32_2 = random.getrandbits(32)
bit32_combined = (bit32_2 << 32) | bit32_1

bit64 == bit32_combined
```

that is, that 64 bit randoms are just 32 bit randoms concatentated together.

With all these knowledge, we can easily generate a solve script

```python
import random, time
from randcrack import RandCrack
from pwn import *

rc = RandCrack()

p = remote("167.99.77.149", 30466)

for run in range(624//2):
    p.sendlineafter(b"> ", b"1")
    p.recvuntil(b"STR: ")
    stre = int(p.recvline().strip())
    p.recvuntil(b"DEX: ")
    dext = int(p.recvline().strip())
    p.recvuntil(b"INT: ")
    inte = int(p.recvline().strip())
    p.recvuntil(b"LUK: ")
    luck = int(p.recvline().strip())
    first = (inte << 16) | luck
    second = (stre << 16) | dext
    rc.submit(first)
    rc.submit(second)

lucky_num = rc.predict_getrandbits(64)
p.sendlineafter(b"> ", b"2")
p.sendlineafter(b"number: ", str(lucky_num).encode())

p.interactive()
"""
OUTPUT:
[+] Opening connection to 159.65.133.6 on port 31708: Done
[*] Switching to interactive mode
Congrats! You have pulled the limited SSS-rated rarity flag-chan!
STF22{W@IFU5_L@1FU5}
"""
```
